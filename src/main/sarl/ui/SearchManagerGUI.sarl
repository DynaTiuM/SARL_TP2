package ui

import javax.swing.JButton
import javax.swing.JComboBox

import javax.swing.JLabel
import javax.swing.JPanel
import javax.swing.JTextField
import java.awt.GridBagLayout
import java.awt.GridBagConstraints
import java.awt.Insets
import holarchy.SearchManagerCallback
import javax.swing.JFrame
import java.awt.Dimension
import java.awt.BorderLayout
import javax.swing.JFileChooser
import javax.swing.JScrollPane
import javax.swing.tree.DefaultMutableTreeNode
import javax.swing.JTree
import javax.swing.tree.DefaultTreeModel
import java.io.File
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.HashMap
import java.util.Map
import org.eclipse.xtend.lib.annotations.Accessors

class SearchManagerGUI extends JFrame {
	var panel : SearchManagerPanel
	var tree : JTree
	var treeModel : DefaultTreeModel
	@Accessors var rootPath : String

	new(callback : SearchManagerCallback) {
		this.title = "Search Manager"
		this.preferredSize = new Dimension(700, 600)
		this.defaultCloseOperation = JFrame.EXIT_ON_CLOSE

		panel = new SearchManagerPanel(callback, this)
		this.contentPane.add(panel, BorderLayout.NORTH)
		
        this.treeModel = new DefaultTreeModel(null)
        this.tree = new JTree(treeModel)
		val treeScrollPane = new JScrollPane(this.tree)
		this.getContentPane().add(treeScrollPane, BorderLayout.CENTER)
		this.pack()
		this.setLocationRelativeTo(null)
		this.setVisible(true)
        this.requestFocus()
    }

	def updateResults(foundFiles : ConcurrentLinkedQueue<File>) {
		val root = new DefaultMutableTreeNode(new File(rootPath).getName)
        
		this.panel.createFileTree(root, foundFiles, rootPath)

		this.treeModel.setRoot(root)
		this.treeModel.reload()
	}
}

class SearchManagerPanel extends JPanel {
	val textField : JTextField = new JTextField(15)
	val extensions = newLinkedList('.sarl', '.txt')
    val comboBox : JComboBox<String> = new JComboBox(extensions)
	val okButton : JButton = new JButton("OK")
    val selectFolderButton : JButton = new JButton("Select Folder")
    val callback : SearchManagerCallback
    val parentGUI : SearchManagerGUI

    new(callback : SearchManagerCallback, parentGUI : SearchManagerGUI) {
		this.callback = callback
		this.parentGUI = parentGUI
		this.setLayout(new GridBagLayout())
		val constraints = new GridBagConstraints()
		constraints.insets = new Insets(5, 5, 5, 5)

		constraints.gridx = 0
		constraints.gridy = 2
		constraints.anchor = GridBagConstraints.LINE_END
		this.add(new JLabel("Path: "), constraints)

        constraints.gridx = 1
        constraints.gridy = 2
		constraints.anchor = GridBagConstraints.LINE_START
		this.add(textField, constraints)
		this.textField.editable = false

		constraints.gridx = 2
		constraints.gridy = 1
		constraints.anchor = GridBagConstraints.LINE_END
		this.add(new JLabel("Extension: "), constraints)

		constraints.gridx = 3
        constraints.gridy = 1
        constraints.anchor = GridBagConstraints.LINE_START
		this.add(comboBox, constraints)

		constraints.gridx = 1
		constraints.gridy = 1
		constraints.anchor = GridBagConstraints.LINE_END
		this.add(selectFolderButton, constraints)

		constraints.gridx = 3
		constraints.gridy = 2
		constraints.anchor = GridBagConstraints.CENTER
		this.add(okButton, constraints)

		okButton.addActionListener [
			handleOkButtonClick()
		]

		selectFolderButton.addActionListener [
			handleSelectFolderClick()
		]
	}

	def handleOkButtonClick() {
		val path = textField.getText
		val criteria = comboBox.getSelectedItem.toString
		callback.onSearch(path, criteria)
	}

	def handleSelectFolderClick() {
		val chooser = new JFileChooser()
		chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY)
		val returnValue = chooser.showOpenDialog(SearchManagerPanel.this)
		if (returnValue == JFileChooser.APPROVE_OPTION) {
			val selectedFile = chooser.getSelectedFile
			textField.setText(selectedFile.getAbsolutePath)

			this.parentGUI.setRootPath(selectedFile.getAbsolutePath)
		}
	}

	def createFileTree(rootNode : DefaultMutableTreeNode, foundFiles : ConcurrentLinkedQueue<File>, rootPath : String) {
		val nodeMap = new HashMap<String, DefaultMutableTreeNode>
		nodeMap.put(rootPath, rootNode)

		for (file : foundFiles) {
			/* 
			 * Le path absolu correspond au chemin complet permettant d'accéder jusqu'au fichier
			 * trouvé par les agents.
			 */
			val absolutePath = file.getAbsolutePath.replace("\\", '/')

			/* 
			 * La méthode substring permet d'extraire une sous-chaîne à partir de l'index spécifié.
			 * Ici, nous utilisons rootPath.length + 1 pour obtenir la partie du chemin qui suit 
			 * immédiatement le chemin racine (rootPath).
			 * 
			 * Par exemple, si le chemin absolu est :
			 * /Users/raphael_perrin/sarl-workspace/AI51_Lab#2_Raphael_PERRIN_A2024/Tree/Dir1/file1.sarl
			 * et que rootPath est :
			 * /Users/raphael_perrin/sarl-workspace/AI51_Lab#2_Raphael_PERRIN_A2024/Tree,
			 * alors relativePath sera :
			 * Dir1/file1.sarl
			 * 
			 * Cela nous permet d'obtenir le chemin relatif par rapport au chemin racine,
			 * permettant une mise en page de la structure des dossiers beaucoup plus claire.
			 */
			val relativePath = absolutePath.substring(rootPath.length + 1)
			
			/* 
			 * Nous ajoutons les dossiers et fichiers dans la vue de l'arbre
			 */
			addFilePathToTree(rootNode, relativePath, nodeMap)
		}
	}

	def addFilePathToTree(rootNode : DefaultMutableTreeNode, filePath : String, nodeMap : Map<String, DefaultMutableTreeNode>) {
		val parts = filePath.split("/")

		var currentNode = rootNode
        val currentPath = new StringBuilder(rootNode.toString)

        for (part : parts) {
            currentPath.append("/").append(part)
			if (!nodeMap.containsKey(currentPath.toString)) {
                val newNode = new DefaultMutableTreeNode(part)
				currentNode.add(newNode)
				nodeMap.put(currentPath.toString, newNode)
                currentNode = newNode
            } else {
				currentNode = nodeMap.get(currentPath.toString)
			}
        }
    }
}