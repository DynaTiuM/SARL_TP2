package holarchy

import io.sarl.api.core.DefaultContextInteractions
import io.sarl.api.core.Initialize
import io.sarl.api.core.InnerContextAccess
import io.sarl.api.core.Lifecycle
import io.sarl.api.core.Logging
import java.util.UUID
import java.io.File
import io.sarl.api.core.ParticipantJoined
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import io.sarl.api.core.Destroy
import io.sarl.api.core.Schedules

agent SearchAgent {

	uses Lifecycle, InnerContextAccess, DefaultContextInteractions, Logging, Schedules

	var directory : File
	var criteria : String
	var parent : UUID

	var map = new ConcurrentHashMap<UUID, File>()
	var isSearchFinished = new AtomicBoolean(false)

	on Initialize {
		synchronized(this) {
			parent = occurrence.spawner
			if (!occurrence.parameters.isEmpty) {
				loggingName = "ROOT AGENT"
			}
		}
		
	}

	on ParticipantJoined [!(isFromMe) && map.containsKey(occurrence.source.ID) &&
		(occurrence.spaceID == innerContext.defaultSpace.spaceID)] {
		innerContext.defaultSpace.emit(occurrence.source.ID,
			new SearchRequest(map.get(occurrence.source.ID) as File, criteria))[it.ID == occurrence.source.ID]
	}

	on SearchRequest {
		criteria = occurrence.criteria
		directory = occurrence.path
		
		if (!directory.exists) {
			throw new IllegalArgumentException("The directory doesn't exist!")
		}
		
		for (subdir : directory.listFiles()[!hidden].toList.filter[isDirectory()]) {
			info("Directory found: " + subdir.toString)
			val aid = UUID::randomUUID
			if (!map.containsKey(subdir.toString)) {
				map.put(aid, new File(subdir.toString()))
				spawnInContextWithID(SearchAgent, aid, innerContext)
			}
		}

		for (subfile : directory.listFiles()[!hidden].toList.filter[isFile() && getName.endsWith(criteria)]) {
			info("File found: " + subfile.toString)
			var foundFile = new File(directory, subfile.getName)
			emit(new FileFound(foundFile))[it.ID == occurrence.source.ID]
		}
		
		synchronized (isSearchFinished) {
			isSearchFinished.set(true)
		}

		if (map.empty && isSearchFinished.get) {
			info("No more tasks: killing myself.")
			killMe
		}
	}
	
	on Destroy {
		emit(new SearchFinished)[it.ID == parent]
	}

	on FileFound {
		emit(new FileFound(occurrence.path))[it.ID == parent]
	}

	on SearchFinished [map.containsKey(occurrence.source.ID)] {
		var childID = occurrence.source.ID
		synchronized (childID) {
			map.remove(childID)
			info("Child removed. Remaining children: " + map.size)
			tryToKillMyself
		}
	}
	
	def tryToKillMyself() {
		if (map.empty && isSearchFinished.get) {
			info("No more children: killing myself.")
			in(300) [killMe]
		}
	}
}
